=========================
推荐系统实验
@Author: 李鹏
@Date:2020/05/28
=========================

实验1：基于内容的推荐

实验流程：
    - 构建电影画像：利用sklearn的tfidf函数将每个电影的类型进行向量化编码，得到每个电影的表示
    - 构建用户画像：利用用户观看的电影和对应的评分，直接求和或者加权求和得到每个用户喜欢的电影类型的向量表示
    - 相似度计算：计算每个用户和每个电影的向量表示之间的余弦相似度，得到对应的矩阵
    - 推荐：根据用户的向量表示，得到最近的K个电影，作为推荐结果
    - 评测：评测准确率、召回率、覆盖率和流行度等指标
注：
    - 由于测试集的预测只是基于训练集中自己的看过的电影，但是由于训练集中该用户看过的电影数可能较少，所以最后的
      准确率可能不高，这时候应该调整训练集和测试集的比例，适当提升训练集比例
    - 为了加速运算，在实验过程中多处采用了矩阵乘积的形式
    - 相较于基于CF的结果，推荐的覆盖率还是提升不小的，这可能是因为每个用户都是基于自己的历史浏览记录各自计算
      推荐结果，因此覆盖得会比较均匀
    - 具体实现时将一些公用函数和评测函数单独进行了处理

===========================

实验2：推荐系统的融合排序

实现流程：
    - 召回：根据基于用户的推荐和基于内容的推荐结果得到召回列表，这里的实现直接将两个矩阵进行了拼接，暂时没有去重，
      最后推荐的时候再去重（这里通过观察之前的推荐结果，假设了矩阵的index就是用户的id）
    - 构建电影画像：对电影的属性进行tf-idf编码，得到电影画像（这里也是得到一个矩阵）
    - 构建用户画像：读取用户数据集，对性别、年龄、职业、邮政编码进行onehot编码，在处理邮政编码的时候为了降低LR模型
      的参数，只提取了邮政编码的第一个数字（含义为用户所在州），最后拼接各个编码得到一个矩阵，行号代表用户id
    - 负采样构建数据集：因为当前数据集只有用户和用户观看的电影，因此需要构建负样本，将（用户，用户没有观看的电影）的
       标签置为0，在这里实现的时候采用了mask,np.where()等操作，实现得比较简洁
    - 对所有样本进行编码表示：对于[(用户，电影),(用户，电影),...]这种np.array,直接转置，得到(2,user_num)形状的
      array，第一行表示用户id，第二行表示电影id，然后分别在用户画像矩阵和电影画像矩阵中lookup，再拼接，就能够得到
      向量表示了
    - 构建LR模型：分割数据集得到训练集和测试集，利用sklearn的逻辑回归函数构建LR模型
    - 重排召回的推荐列表：利用模型的predict_proba函数，得到预测为1的概率，根据此概率重排推荐列表
    - 推荐: 为用户id推荐重排列表的前K个
    - 评测模型：评测准确率、召回率、覆盖率、流行度等指标

注：
    - 因为基于内容的模型效果不是太好，最后的实验结果会比单独基于用户的低，不过流行度会提高一些，具体结果参见user_cf_metrix.PNG,
      content_base_rec_metric.PNG,mixed_rec_metric.PNG等文件
    - 待优化：实现过程中虽然有考虑代码架构，考虑耦合和解耦合，但是最后还是有几个地方写得不够优雅，写得太死，需要后面再提高代码质量

========================

代码整体依赖：rec_base.py  公用函数，如加载数据集、格式转换等
           ---> task1.py & task2.py 两个实验主要代码
           ---> metric.py  评测代码
